<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hexagonal Flip Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        :root {
            --bg-color: #0a0a1a;
            --grid-color: rgba(80, 200, 255, 0.15);
            --text-color: #e0f0ff;
            --accent: #00d4ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: var(--bg-color);
            background-image:
                radial-gradient(ellipse at 50% 0%, rgba(0, 100, 150, 0.2) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 100%, rgba(100, 0, 150, 0.1) 0%, transparent 50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        h1 {
            color: var(--text-color);
            font-size: clamp(1rem, 4vw, 1.5rem);
            margin-bottom: 20px;
            text-shadow: 0 0 20px var(--accent);
            letter-spacing: 3px;
            opacity: 0;
            animation: fadeIn 1s ease forwards 0.5s;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .scene {
            width: 300px;
            height: 350px;
            perspective: 800px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tile-container {
            position: relative;
            width: 200px;
            height: 230px;
            transform-style: preserve-3d;
            transform: rotateX(55deg);
        }

        .tile-pivot {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
        }

        .hexagon-tile {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            cursor: grab;
        }

        .hexagon-tile.flipping {
            cursor: grabbing;
        }

        .hex-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
        }

        .hex-face canvas {
            width: 100%;
            height: 100%;
        }

        .hex-face.front {
            transform: translateZ(1px);
        }

        .hex-face.back {
            transform: translateZ(-1px) rotateX(180deg);
        }

        .direction-indicators {
            position: absolute;
            width: 280px;
            height: 320px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .direction-arrow {
            position: absolute;
            font-size: 24px;
            color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
            opacity: 0.4;
            transition: all 0.3s ease;
            animation: pulse 2s ease-in-out infinite;
            cursor: pointer;
            pointer-events: auto; /* чтобы стрелки были кликабельны */
            z-index: 10;
        }

        .direction-arrow.active {
            opacity: 1;
            transform: scale(1.4);
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        /* 6 directions: top-right, right, bottom-right, bottom-left, left, top-left */
        .direction-arrow:nth-child(1) { top: 5%; right: 5%; }
        .direction-arrow:nth-child(2) { top: 50%; right: -5%; transform: translateY(-50%); }
        .direction-arrow:nth-child(3) { bottom: 5%; right: 5%; }
        .direction-arrow:nth-child(4) { bottom: 5%; left: 5%; }
        .direction-arrow:nth-child(5) { top: 50%; left: -5%; transform: translateY(-50%); }
        .direction-arrow:nth-child(6) { top: 5%; left: 5%; }

        .info {
            margin-top: 30px;
            color: var(--text-color);
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            opacity: 0.7;
            text-align: center;
            letter-spacing: 1px;
        }

        .moves-counter {
            color: var(--accent);
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            margin-top: 10px;
        }

        .particles {
            position: fixed;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--accent);
            border-radius: 50%;
            opacity: 0;
        }

        @keyframes float {
            0% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 0.6; }
            90% { opacity: 0.6; }
            100% { transform: translateY(-100vh) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="particles" id="particles"></div>

    <h1>HEXAGONAL FLIP</h1>

    <div class="scene" id="scene">
        <div class="direction-indicators" id="directionIndicators">
            <span class="direction-arrow" data-dir="0">↗</span>
            <span class="direction-arrow" data-dir="1">→</span>
            <span class="direction-arrow" data-dir="2">↘</span>
            <span class="direction-arrow" data-dir="3">↙</span>
            <span class="direction-arrow" data-dir="4">←</span>
            <span class="direction-arrow" data-dir="5">↖</span>
        </div>

        <div class="tile-container" id="tileContainer">
            <div class="tile-pivot" id="tilePivot">
                <div class="hexagon-tile" id="hexTile">
                    <div class="hex-face front" id="frontFace"></div>
                    <div class="hex-face back" id="backFace"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="info">
        Свайпни или кликни на стрелку
        <div class="moves-counter">Переворотов: <span id="moveCount">0</span></div>
    </div>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            document.documentElement.classList.toggle('dark', event.matches);
        });

        // Constants
        const TILE_WIDTH = 200;
        const TILE_HEIGHT = 230;

        // Game state
        const state = {
            moveCount: 0,
            isFlipping: false,
            frontColors: [],
            backColors: []
        };

        // Исправленные углы осей вращения (вдоль ребра)
        // Индексы: 0 - topRight, 1 - right, 2 - bottomRight, 3 - bottomLeft, 4 - left, 5 - topLeft
        const FLIP_DIRECTIONS = [
            { name: 'topRight', edgeAngle: 30 },      // ось под 30°
            { name: 'right', edgeAngle: 90 },          // ось под 90°
            { name: 'bottomRight', edgeAngle: 150 },   // ось под 150°
            { name: 'bottomLeft', edgeAngle: -150 },   // ось под -150° (или 210°)
            { name: 'left', edgeAngle: -90 },          // ось под -90° (или 270°)
            { name: 'topLeft', edgeAngle: -30 }        // ось под -30° (или 330°)
        ];

        // Генератор случайного яркого цвета
        function randomColor() {
            const hue = Math.random() * 360;
            const sat = 70 + Math.random() * 30;
            const light = 50 + Math.random() * 20;
            return `hsl(${hue}, ${sat}%, ${light}%)`;
        }

        // Затемнение цвета (для градиента)
        function darkenColor(hsl, amount) {
            const match = hsl.match(/hsl\(([\d.]+),\s*([\d.]+)%,\s*([\d.]+)%\)/);
            if (match) {
                const h = parseFloat(match[1]);
                const s = parseFloat(match[2]);
                const l = Math.max(0, Math.min(100, parseFloat(match[3]) + amount));
                return `hsl(${h}, ${s}%, ${l}%)`;
            }
            return hsl;
        }

        // Получить вершины шестиугольника (ориентация: острым углом вверх)
        function getHexVertices(centerX, centerY, radius) {
            const vertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i * 60 - 90) * Math.PI / 180; // начинаем с верхней вершины
                vertices.push({
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            }
            return vertices;
        }

        // Отрисовка грани с цветами и номерами секторов
        function drawFace(faceElement, colors) {
            faceElement.innerHTML = '';

            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 460;

            const ctx = canvas.getContext('2d');
            const centerX = 200;
            const centerY = 230;
            const radius = 190;

            const vertices = getHexVertices(centerX, centerY, radius);

            // Рисуем 6 треугольных секторов
            for (let i = 0; i < 6; i++) {
                const color = colors[i];
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % 6];

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
                ctx.closePath();

                // Градиент от центра к краю
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                const gradient = ctx.createLinearGradient(centerX, centerY, midX, midY);
                gradient.addColorStop(0, darkenColor(color, 15));
                gradient.addColorStop(1, color);

                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Рисуем номер сектора (i+1) в центре сектора
                const textX = centerX + (midX - centerX) * 0.6;
                const textY = centerY + (midY - centerY) * 0.6;

                ctx.font = 'bold 28px "Orbitron", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 8;
                ctx.fillStyle = 'white';
                ctx.fillText(i + 1, textX, textY);
                ctx.shadowBlur = 0; // сброс тени для остальных элементов
            }

            // Контур шестиугольника
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < 6; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 5;
            ctx.stroke();

            // Декоративный центр
            ctx.beginPath();
            ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
            const centerGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 15);
            centerGrad.addColorStop(0, 'rgba(255,255,255,0.7)');
            centerGrad.addColorStop(1, 'rgba(255,255,255,0.2)');
            ctx.fillStyle = centerGrad;
            ctx.fill();

            faceElement.appendChild(canvas);
        }

        // Обновить обе грани
        function updateFaces() {
            drawFace(document.getElementById('frontFace'), state.frontColors);
            drawFace(document.getElementById('backFace'), state.backColors);
        }

        // Вычислить смещение точки поворота к ребру
        function getEdgeOffset(directionIndex) {
            // Угол от центра к середине ребра (для смещения pivot)
            const angleToEdge = (directionIndex * 60 - 60) * Math.PI / 180;
            const edgeDistance = TILE_HEIGHT / 2 * 0.8;
            return {
                x: Math.cos(angleToEdge) * edgeDistance,
                y: Math.sin(angleToEdge) * edgeDistance
            };
        }

        // Анимация переворота
        function flipTile(directionIndex) {
            if (state.isFlipping) return;

            const direction = FLIP_DIRECTIONS[directionIndex];
            state.isFlipping = true;

            const pivot = document.getElementById('tilePivot');
            const hexTile = document.getElementById('hexTile');

            hexTile.classList.add('flipping');

            const edge = getEdgeOffset(directionIndex);

            // Ось вращения (вдоль ребра)
            const edgeAxisAngle = direction.edgeAngle * Math.PI / 180;
            const axisX = Math.cos(edgeAxisAngle);
            const axisY = Math.sin(edgeAxisAngle);

            let startTime = null;
            const duration = 500;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);

                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                const rotationDeg = eased * 180;

                pivot.style.transform = `
                    translate3d(${edge.x}px, ${edge.y}px, 0)
                    rotate3d(${axisX}, ${axisY}, 0, ${rotationDeg}deg)
                    translate3d(${-edge.x}px, ${-edge.y}px, 0)
                `;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Завершение анимации
                    state.moveCount++;
                    document.getElementById('moveCount').textContent = state.moveCount;

                    // Меняем местами лицевую и тыльную стороны
                    const frontFace = document.getElementById('frontFace');
                    const backFace = document.getElementById('backFace');

                    frontFace.classList.remove('front');
                    frontFace.classList.add('back');
                    frontFace.id = 'backFace';

                    backFace.classList.remove('back');
                    backFace.classList.add('front');
                    backFace.id = 'frontFace';

                    // Обновляем цвета: новая тыльная сторона получает новые цвета
                    const newBackColors = Array.from({ length: 6 }, () => randomColor());
                    [state.frontColors, state.backColors] = [state.backColors, newBackColors];

                    // Перерисовываем грани
                    updateFaces();

                    // Сбрасываем трансформацию
                    pivot.style.transform = '';
                    hexTile.classList.remove('flipping');

                    createParticles();

                    state.isFlipping = false;
                }
            }

            requestAnimationFrame(animate);
        }

        // Эффект частиц
        function createParticles() {
            const container = document.getElementById('particles');
            const rect = document.getElementById('scene').getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = `${centerX + (Math.random() - 0.5) * 150}px`;
                particle.style.top = `${centerY + (Math.random() - 0.5) * 150}px`;
                particle.style.animation = `float ${2 + Math.random() * 2}s ease-out forwards`;
                particle.style.animationDelay = `${Math.random() * 0.2}s`;

                container.appendChild(particle);
                setTimeout(() => particle.remove(), 4000);
            }
        }

        // Обработка свайпов
        let touchStart = { x: 0, y: 0 };
        let isSwiping = false;

        function getSwipeDirection(dx, dy) {
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            const normalizedAngle = ((angle + 360) % 360);

            if (normalizedAngle >= 330 || normalizedAngle < 30) return 1;   // right
            if (normalizedAngle >= 30 && normalizedAngle < 90) return 2;    // bottom-right
            if (normalizedAngle >= 90 && normalizedAngle < 150) return 3;   // bottom-left
            if (normalizedAngle >= 150 && normalizedAngle < 210) return 4;  // left
            if (normalizedAngle >= 210 && normalizedAngle < 270) return 5;  // top-left
            return 0;  // top-right (270-330)
        }

        function handleSwipeStart(e) {
            if (state.isFlipping) return;
            const point = e.touches ? e.touches[0] : e;
            touchStart = { x: point.clientX, y: point.clientY };
            isSwiping = true;
        }

        function handleSwipeMove(e) {
            if (!isSwiping || state.isFlipping) return;

            const point = e.touches ? e.touches[0] : e;
            const dx = point.clientX - touchStart.x;
            const dy = point.clientY - touchStart.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            const arrows = document.querySelectorAll('.direction-arrow');
            arrows.forEach(arrow => arrow.classList.remove('active'));

            if (distance > 20) {
                const dir = getSwipeDirection(dx, dy);
                arrows[dir].classList.add('active');
            }
        }

        function handleSwipeEnd(e) {
            if (!isSwiping || state.isFlipping) return;
            isSwiping = false;

            const point = e.changedTouches ? e.changedTouches[0] : e;
            const dx = point.clientX - touchStart.x;
            const dy = point.clientY - touchStart.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            document.querySelectorAll('.direction-arrow').forEach(a => a.classList.remove('active'));

            if (distance > 40) {
                const direction = getSwipeDirection(dx, dy);
                flipTile(direction);
            }
        }

        // Клавиатурная поддержка
        function handleKeydown(e) {
            if (state.isFlipping) return;

            const keyMap = {
                'KeyE': 0,        // top-right
                'KeyD': 1,        // right
                'KeyC': 2,        // bottom-right
                'KeyZ': 3,        // bottom-left
                'KeyA': 4,        // left
                'KeyQ': 5,        // top-left
                'ArrowRight': 1,
                'ArrowLeft': 4
            };

            if (keyMap.hasOwnProperty(e.code)) {
                e.preventDefault();
                flipTile(keyMap[e.code]);
            }
        }

        // Инициализация
        function init() {
            // Генерируем начальные цвета
            state.frontColors = Array.from({ length: 6 }, () => randomColor());
            state.backColors = Array.from({ length: 6 }, () => randomColor());

            // Рисуем грани
            drawFace(document.getElementById('frontFace'), state.frontColors);
            drawFace(document.getElementById('backFace'), state.backColors);

            // Клики на стрелки
            document.querySelectorAll('.direction-arrow').forEach(arrow => {
                arrow.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dir = parseInt(arrow.getAttribute('data-dir'), 10);
                    flipTile(dir);
                });
            });

            const scene = document.getElementById('scene');

            scene.addEventListener('mousedown', handleSwipeStart);
            scene.addEventListener('mousemove', handleSwipeMove);
            scene.addEventListener('mouseup', handleSwipeEnd);
            scene.addEventListener('mouseleave', handleSwipeEnd);

            scene.addEventListener('touchstart', handleSwipeStart, { passive: true });
            scene.addEventListener('touchmove', handleSwipeMove, { passive: true });
            scene.addEventListener('touchend', handleSwipeEnd);

            document.addEventListener('keydown', handleKeydown);

            // Фоновые частицы
            setInterval(() => {
                if (Math.random() > 0.8) {
                    const container = document.getElementById('particles');
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = `${Math.random() * 100}%`;
                    particle.style.top = '100%';
                    particle.style.animation = `float ${5 + Math.random() * 5}s linear forwards`;
                    container.appendChild(particle);
                    setTimeout(() => particle.remove(), 10000);
                }
            }, 500);
        }

        init();
    </script>
</body>
</html>